
#ifndef SYNTH_H_INCLUDED
#define SYNTH_H_INCLUDED
#include "PhysicalModel.h"

const int MAX_POLYPHONY = 1;

// ================================================================================================
struct PERCSound : public SynthesiserSound
{
	PERCSound() {}
	bool appliesToNote(int /*midiNoteNumber*/) override { return true; }
	bool appliesToChannel(int /*midiChannel*/) override { return true; }
};
// ================================================================================================

class PERCVoice : public SynthesiserVoice
{
private:
	ScopedPointer<PERC> note;
    float Tens,Damp,Thik,Vol; int Mtrl;

public:
    
    PERCVoice(float ten,float damp,float thik,int mtrl,float vol): Tens(ten),Damp(damp),Thik(thik),Mtrl(mtrl), Vol(vol)     {}
    
	bool canPlaySound(SynthesiserSound* sound) override { return sound != nullptr; }
	
	void startNote(int midiNoteNumber, float velocity, SynthesiserSound*, int /*currentPitchWheelPosition*/) override {
        note = new PERC(midiNoteNumber, velocity, (float)getSampleRate(),Tens,Damp,Thik,Mtrl,Vol);}
	
    void stopNote(float /*velocity*/, bool /*allowTailOff*/) override {}
    
    void pitchWheelMoved(int /*newValue*/) override {}

    void controllerMoved(int /*controllerNumber*/, int /*newValue*/) override {}
  
	void renderNextBlock(AudioSampleBuffer& outputBuffer, int startSample, int numSamples) override {
		float* buf = (float *)outputBuffer.getWritePointer(0);
		if (note != nullptr) {
			note->renderToBuffer(&buf[startSample], numSamples, isKeyDown() /*|| isSustainPedalDown()*/);
			if (!note->is_alive()) {
				clearCurrentNote();
                note = nullptr;}
		}
	}
};

// ================================================================================================

class PercSynthPlayer : public AudioSource , public Slider::Listener, public ComboBox::Listener
{
private:
	AudioDeviceManager& inputDeviceManager;
	AudioDeviceManager& outputDeviceManager;
	MidiKeyboardState& keyboardState;
	Synthesiser synth;
	MidiMessageCollector midiCollector;
	AudioSourcePlayer audioSourcePlayer;

public:
    float   stiffness = 0.0, damping = 0.1, thickness = 0.05,   volume = 50.0;  // Parameters initial values
    int     material = 1;
    
	PercSynthPlayer(MidiKeyboardState& _state, AudioDeviceManager& _in, AudioDeviceManager& _out) : keyboardState(_state), inputDeviceManager(_in), outputDeviceManager(_out)
	{
		inputDeviceManager.addMidiInputCallback(String::empty, &midiCollector);
		inputDeviceManager.setMidiInputEnabled(MidiInput::getDevices()[0], true);
        
		outputDeviceManager.addAudioCallback(&audioSourcePlayer);

		audioSourcePlayer.setSource(this);
        
        for (int i = 0; i < MAX_POLYPHONY; ++i)
            synth.addVoice(new PERCVoice(stiffness,damping,thickness,material,volume));
        
        synth.clearSounds();
        
		synth.addSound(new PERCSound());
	}
    
	~PercSynthPlayer() {
		audioSourcePlayer.setSource(nullptr);
		inputDeviceManager.removeMidiInputCallback(String::empty, &midiCollector);
		outputDeviceManager.removeAudioCallback(&audioSourcePlayer);
		outputDeviceManager.closeAudioDevice();
	}

	void prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate) override {
		midiCollector.reset(sampleRate);
		synth.setCurrentPlaybackSampleRate(sampleRate);
	}
    
    void sliderValueChanged(Slider *slider) override {
        if      (slider->getComponentID() == "stiffness")   stiffness = slider->getValue();
        else if (slider->getComponentID() == "damping")     damping   = slider->getValue();
        else if (slider->getComponentID() == "thickness")   thickness = slider->getValue();
        else if (slider->getComponentID() == "volume")      volume    = slider->getValue();

        synth.clearVoices();
        for (int i = 0; i < MAX_POLYPHONY; ++i)
            synth.addVoice(new PERCVoice(stiffness,damping,thickness,material,volume));
    }
    
    void comboBoxChanged(ComboBox *box) override {
        if (box->getComponentID() == "materials") material = box->getSelectedId();
        
        synth.clearVoices();
        for (int i = 0; i < MAX_POLYPHONY; ++i)
            synth.addVoice(new PERCVoice(stiffness,damping,thickness,material,volume));
    }

	void releaseResources() override {}
 
	void getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill) override {
		
        bufferToFill.clearActiveBufferRegion();
		MidiBuffer incomingMidi;
		midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);

		// Pass these messages to the keyboard state so that it can update the component
		// to show on-screen which keys are being pressed on the physical midi keyboard.	
		const int startSample = 0;
		const bool injectIndirectEvents = true;  // add midi messages generated by clicking on the on-screen keyboard.
        keyboardState.processNextMidiBuffer(incomingMidi, startSample, bufferToFill.numSamples, injectIndirectEvents);

        
		synth.renderNextBlock(*bufferToFill.buffer, incomingMidi, startSample, bufferToFill.numSamples);
	}
};

#endif  // SYNTH_H_INCLUDED
